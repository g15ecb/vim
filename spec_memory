///////////////////////////////////////////////////////////////////////////////
// Objects
///////////////////////////////////////////////////////////////////////////////

// Todo: lock this down...
type ID

type Env def=
  [|
  env |> 
    env_dataset: ID -> Dataset
    env_region: ID -> Region
    env_node: ID -> Node
  |]

type Node def= 
  [| 
  node |>
  node_nvram_capacity: Nat0
  node_dram_capacity: Nat0
  node_nvram_allocated: Set[Region]
  node_dram_allocate: Set[Region]
  |]

type Dataset def= 
  [|
  dataset |>
  dataset_regions: Set[ID]
  |]
    // this needs to be tidied up: where did you get env from???
    INV // only homogenous region datasets
      VAL env :: Env IN 
      !EXIST dataset_id IN dom(env_dataset(env)).
        {region_id1,region_id2} INCLUDED_IN
          dataset_regions(env_dataset(env)(dataset_id))
        AND 
        env_region(env)(region_id1) != env_region(env)(region_id2) 

type Region def= NVRAM | DRAM

///////////////////////////////////////////////////////////////////////////////
// Environment
///////////////////////////////////////////////////////////////////////////////

// Bootup an environment comprising *n_nodes* each with *nvram_capacity* and
// *dram_capacity*.
env_boot def= Nat -> Nat -> Nat -> Env
env_boot n_nodes nvram_capacity dram_capacity env' =
  INV_BEGIN
  POST: #(dom(env_dataset(env'))) == 0
        AND
        #(dom(env_region(env'))) == 0
        AND
        FORALL n IN dom(env_node(env')).
          node_nvram_capacity(env_node(env')(n)) == nvram_capacity
          AND
          node_dram_capacity(env_node(env')(n)) == dram_capacity
          AND
          #(node_nvram_allocated(env_node(env')(n))) == 0
          AND
          #(node_dram_allocated(env_node(env')(n))) == 0
        AND
        #(dom(env_node(env'))) == n_nodes
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

///////////////////////////////////////////////////////////////////////////////
// Datasets
///////////////////////////////////////////////////////////////////////////////

// Create a dataset of *size* regions.
dataset_nvram_create def= Env -> Nat -> Env
dataset_nvram_create env size env' =
  INV_BEGIN
  PRE:  size <= nodes_available_nvram_regions(env_nodes(env))
  POST: dom(env_region(env')) STRICTLY_INCLUDES dom(env_region(env))
        AND
        dom(env_dataset(env')) STRICTLY_INCLUDES dom(env_region(env))
        AND
          // singleton set; dataset_id is the dataset id associated with that created
          VAL {dataset_id} = dom(env_dataset(env')) \ dom(env_dataset(env)) IN 
          // dataset entails the requested number of regions
          #(dataset_regions(env_dataset(env')(dataset_id))) == size
        AND // dom of env_nodes remains the same...
        dom(env_node(env')) == dom(env_node(env))
        AND // but at least one node's state has changed... 
        EXISTS node_id' IN dom(env_node(env')).
          (EXISTS node_id IN dom(env_node(env)).
            node_id' == node_id 
            AND
            node_nvram_allocated(env_node(env')(node_id')) STRICTLY_INCLUDES 
              node_nvram_regions(env_node(env)(node_id)))
  INV_END
  BODY_BEGIN
  BODY_END
END

// Frees a dataset which entails freeing its constituent regions and updating
// the NVRAM free stores of the nodes that housed those regions. Note that the
// id of the freed dataset is not recycled.  
// Nothing on multiple users having a handle on the dataset
dataset_nvram_free def= Env -> ID -> Env
dataset_nvram_free env id env' =
  INV_BEGIN
  PRE:  EXISTS d IN env_datasets(env). dataset_id(d) == id 
  POST: nodes_available_nvram_regions(env_nodes(env)) <
          nodes_available_nvram_regions(env_nodes(env'))
        AND
        EXISTS n' IN env_nodes(env').
          (EXISTS n IN env_nodes(env).
            node_id(n') == node_id(n) AND 
              node_free_nvram_regions(n') > node_free_nvram_regions(n))
        AND
        NOT EXISTS d IN env_datasets(env').
          dataset_id(d) == id
        AND
        NOT EXISTS r IN env_regions(env').
          r IN dataset_regions(d)
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

// Find me the dataset in *env* with the given *id*
dataset_find def= Env -> Int -> Dataset
dataset_find env id d' =
  INV_BEGIN
  PRE:  EXISTS d IN env_datasets(env). id(d) = id
  POST: dataset_id(d') = id
  INV_END
END

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

// tell me how many free NVRAM region slots a node has 
node_free_nvram_regions def= Node -> Int
node_free_nvram_regions n free' =
  INV_BEGIN
  POST: 
    free' >= 0
  INV_END
  BODY_BEGIN
    free' = node_nvram_region_capacity(n) - #(node_nvram_rgns(n))
    RETURN free'
  BODY_END
END

// Add a node with the given nvram and dram capacities to an environment
node_add def= Env -> Int -> Int -> Int -> Env
node_add env baseNodeID nvram_capacity dram_capacity env' =
  INV_BEGIN
    PRE:  baseNodeID >= 0
          AND
          nvram_capacity > 0
          AND
          dram_capacity > 0
    POST: #env_nodes(env') > #env_nodes(env)
          AND
          env_node_id(env') > env_node_id(env)
          AND
          EXISTS n IN env_nodes(env').
            node_id(n) = baseNodeID 
            AND
            node_nvram_region_capacity(n) = nvram_capacity
            AND
            node_dram_region_capacity(n) = dram_capacity
            AND
            #(node_nvram_rgns(n)) = 0
            AND
            #(node_dram_rgns(n)) = 0
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

// what to do with a node's data when it dies, particularly if not enough space
// exists on other nodes to maintain its data
node_remove def= Env -> Env
...

// Over nodes...

// tell me now many nvram regions are available in the environment
nodes_available_nvram_regions def= Env -> Int
nodes_available_nvram_regions env free' =
  INV_BEGIN
  POST: 
    free' >= 0
  INV_END
END

// Allocates the relevant number of regions for *size* of memory requested.
nodes_select_and_alloc_nvram_regions def= Env -> Int -> Env
nodes_select_and_alloc_nvram_regions env size env' =
  INV_BEGIN
  PRE:  nodes_available_nvram_regions(env_nodes(ns)) <= size
  POST: #(env_regions(env')) = #(env_regions(env)) + size
        AND
        EXISTS n' IN env_nodes(env'). 
          (EXISTS n IN env_nodes(env). 
            node_id(n') == node_id(n) 
            AND
            #(node_nvram_rgns(n')) > #(node_nvram_rgns(n))
            AND 
            node_nvram_region_capacity(n') < node_nvram_region_capacity(n))
        AND
        env_region_id(env') = env_region_id(env) + size
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

///////////////////////////////////////////////////////////////////////////////
// Regions
///////////////////////////////////////////////////////////////////////////////

// Allocate a region on a given *node_id*. This function would ideally be called
// by nodes_select_and_alloc_nvram_regions.
region_create_nvram def= Env -> Int -> Env
region_create_nvram env node_id env' =
  INV_BEGIN
    PRE:  EXISTS n IN env_nodes(env). node_id(n) == node_id
            AND node_free_nvram_regions(n) > 0 // at least one slot free on n
    POST: env_regions(env') INCLUDES env_regions(env)
          AND
          #(env_regions(env')) > #(env_regions(env))
          AND
          EXISTS n' IN env_nodes(env').
            (EXISTS n IN env_nodes(env).
              node_id(n') == node_id(n) == node_id
              AND
              node_free_nvram_regions(n') < node_free_nvram_regions(n))
          AND
          env_region_id(env') > env_region_id(env)
          // Note: missing nvram check on region alloc'd on n
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

// Delete n's region with the given id, elimintating it from the environment, as
// well.
region_nvram_delete def= Env -> Int -> Int -> Env
region_nvram_delete env node_id region_id env' =
  INV_BEGIN
  PRE:  EXISTS n IN env_nodes(env). 
          node_id(n) == node_id
          AND
          (EXISTS r IN node_nvram_rgns(n).
            region_id(r) == region_id)
        AND
        EXISTS r IN env_regions(env). region_id(r) == region_id
  POST: EXISTS n' IN env_nodes(env'). 
          (EXISTS n IN env_nodes(env). 
            node_id(n') == node_id(n) == node_id
            AND
            (NOT EXISTS r IN node_rgns(n').
              region_id(r) == region_id)
            AND
            node_nvram_region_capacity(n') > node_nvram_region_capacity(n)
            AND
            #(node_nvram_rgns(n')) < #(node_nvram_rgns(n)))
        AND
        NOT EXISTS r IN env_regions(env). region_id(r) == region_id
        AND
        #(env_regions(env')) < #(env_regions(env))
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

// Used for generating unique IDs, which at this time are just strictly
// increasing integers.
succ def= Int -> Int
succ i i' =
  INV_BEGIN
  POST: i' > i
  INV_END
  BODY_BEGIN
    RETURN i + 1
  BODY_END
END
