///////////////////////////////////////////////////////////////////////////////
// Objects
///////////////////////////////////////////////////////////////////////////////

type ID

type Env def=
  [|
  env |> 
    env_dataset: ID -> Dataset
    env_region: ID -> Region
    env_node: ID -> Node
  |]

// (nvram_capacity, dram_capacity, nvram_allocated_regions, // dram_allocated_regions)
type Node def= Nat0 * Nat0 * Set[Region] * Set[Region]

type Dataset def= Set[ID] 
    INV
      VAL env :: Env IN 
      !EXIST d IN dom(env_dataset(env)).
        {r1,r2} INCLUDED_IN env_dataset(env)(d) // implies #(env_dataset(env)(d)) > 1
        AND 
        env_region(env)(r1) != env_region(env)(r2) // dataset member regions must be homogenous

type Region def= NVRAM | DRAM

///////////////////////////////////////////////////////////////////////////////
// Object Equality
///////////////////////////////////////////////////////////////////////////////

(==) def= Node -> Node -> Bool
(==) n1 n2 = 
  INV_BEGIN
  INV_END
  BODY_BEGIN
    node_id(n1) == node_id(n2)
  BODY_END
END

(==) def= Dataset -> Dataset -> Bool
(==) d1 d2 = 
  INV_BEGIN
  INV_END
  BODY_BEGIN
    dataset_id(d1) == dataset_id(d2)
  BODY_END
END

(==) def= Region -> Region -> Bool
(==) r1 r2 = 
  INV_BEGIN
  INV_END
  BODY_BEGIN
    region_id(r1) == region_id(r2)
  BODY_END
END

// Inequality is negation of the above for each of the respective objects.

///////////////////////////////////////////////////////////////////////////////
// Environment
///////////////////////////////////////////////////////////////////////////////

// Give me an environemt with N nodes, each with the specified NVRAM and
// respective DRAM capacity.
// Nat => > 0
env_boot def= Nat -> Nat -> Nat -> Env
env_boot nodes nvram_capacity dram_capacity env' =
  INV_BEGIN
  POST: #(dom(env_dataset(env'))) == 0
        AND
        #(dom(env_region(env'))) == 0
        AND
        FORALL n IN dom(env_node(env')).
          node_nvram_region_capacity(env_node(env')(n)) == nvram_capacity
          AND
          node_dram_region_capacity(env_node(env')(n)) == dram_capacity
          AND
          #(node_nvram_rgns(env_node(env')(n))) == 0
          AND
          #(node_dram_rgns(env_node(env')(n))) == 0
        AND
        #(dom(env_node(env'))) == nodes
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

///////////////////////////////////////////////////////////////////////////////
// Datasets
///////////////////////////////////////////////////////////////////////////////

// Creates a dataset with a given size (# of required region slots for the
// dataset.)
dataset_nvram_create def= Env -> Nat -> Env
dataset_nvram_create env size env' =
  INV_BEGIN
  PRE:  size <= nodes_available_nvram_regions(env_nodes(env))
  POST: env_region(env') STRICTLY_INCLUDES env_region(env)
        AND
        env_dataset(env') STRICTLY_INCLUDES env_region(env)
        AND
          // singleton set
          VAL {d} = dom(env_dataset(env')) \ dom(env_dataset(env)) IN 
          // dataset entails the requested number of regions
          #(dataset_regions(env_dataset(env')(d))) == size
        AND
        dom(env_node(env')) == dom(env_node(env))
        AND
        EXISTS n' IN dom(env_node(env')).
          (EXISTS n IN dom(env_node(env)).
            n' == n 
            AND
            node_nvram_regions(env_node(env')(n')) STRICTLY_INCLUDES 
              node_nvram_regions(env_node(env)(n)))
  INV_END
  BODY_BEGIN
    VAL ds_id' = succ(env_dataset_id(env)) IN
    VAL env'' = nodes_select_and_alloc_nvram_regions(env, size) IN
    VAL rgns' = env_regions(env'') IN
    VAL ns' = env_nodes(env'') IN
    VAL rgn_id = env_region_id(env'') IN
    VAL allocd_rgns = rgns' \ env_regions(env) IN
    VAL env' = Env(ns',
               env_datasets(env) CUP {Dataset(ds_id', allocd_rgns)},
               rgns',
               rgn_id',
               ds_id')
    IN
    RETURN env'
  BODY_END
END

// Frees a dataset which entails freeing its constituent regions and updating
// the NVRAM free stores of the nodes that housed those regions. Note that the
// id of the freed dataset is not recycled.  
// Nothing on multiple users having a handle on the dataset
dataset_nvram_free def= Env -> ID -> Env
dataset_nvram_free env id env' =
  INV_BEGIN
  PRE:  EXISTS d IN env_datasets(env). dataset_id(d) == id 
  POST: nodes_available_nvram_regions(env_nodes(env)) <
          nodes_available_nvram_regions(env_nodes(env'))
        AND
        EXISTS n' IN env_nodes(env').
          (EXISTS n IN env_nodes(env).
            node_id(n') == node_id(n) AND 
              node_free_nvram_regions(n') > node_free_nvram_regions(n))
        AND
        NOT EXISTS d IN env_datasets(env').
          dataset_id(d) == id
        AND
        NOT EXISTS r IN env_regions(env').
          r IN dataset_regions(d)
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

// Find me the dataset in *env* with the given *id*
dataset_find def= Env -> Int -> Dataset
dataset_find env id d' =
  INV_BEGIN
  PRE:  EXISTS d IN env_datasets(env). id(d) = id
  POST: dataset_id(d') = id
  INV_END
END

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

// tell me how many free NVRAM region slots a node has 
node_free_nvram_regions def= Node -> Int
node_free_nvram_regions n free' =
  INV_BEGIN
  POST: 
    free' >= 0
  INV_END
  BODY_BEGIN
    free' = node_nvram_region_capacity(n) - #(node_nvram_rgns(n))
    RETURN free'
  BODY_END
END

// Add a node with the given nvram and dram capacities to an environment
node_add def= Env -> Int -> Int -> Int -> Env
node_add env baseNodeID nvram_capacity dram_capacity env' =
  INV_BEGIN
    PRE:  baseNodeID >= 0
          AND
          nvram_capacity > 0
          AND
          dram_capacity > 0
    POST: #env_nodes(env') > #env_nodes(env)
          AND
          env_node_id(env') > env_node_id(env)
          AND
          EXISTS n IN env_nodes(env').
            node_id(n) = baseNodeID 
            AND
            node_nvram_region_capacity(n) = nvram_capacity
            AND
            node_dram_region_capacity(n) = dram_capacity
            AND
            #(node_nvram_rgns(n)) = 0
            AND
            #(node_dram_rgns(n)) = 0
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

// what to do with a node's data when it dies, particularly if not enough space
// exists on other nodes to maintain its data
node_remove def= Env -> Env
...

// Over nodes...

// tell me now many nvram regions are available in the environment
nodes_available_nvram_regions def= Env -> Int
nodes_available_nvram_regions env free' =
  INV_BEGIN
  POST: 
    free' >= 0
  INV_END
END

// Allocates the relevant number of regions for *size* of memory requested.
nodes_select_and_alloc_nvram_regions def= Env -> Int -> Env
nodes_select_and_alloc_nvram_regions env size env' =
  INV_BEGIN
  PRE:  nodes_available_nvram_regions(env_nodes(ns)) <= size
  POST: #(env_regions(env')) = #(env_regions(env)) + size
        AND
        EXISTS n' IN env_nodes(env'). 
          (EXISTS n IN env_nodes(env). 
            node_id(n') == node_id(n) 
            AND
            #(node_nvram_rgns(n')) > #(node_nvram_rgns(n))
            AND 
            node_nvram_region_capacity(n') < node_nvram_region_capacity(n))
        AND
        env_region_id(env') = env_region_id(env) + size
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

///////////////////////////////////////////////////////////////////////////////
// Regions
///////////////////////////////////////////////////////////////////////////////

// Allocate a region on a given *node_id*. This function would ideally be called
// by nodes_select_and_alloc_nvram_regions.
region_create_nvram def= Env -> Int -> Env
region_create_nvram env node_id env' =
  INV_BEGIN
    PRE:  EXISTS n IN env_nodes(env). node_id(n) == node_id
            AND node_free_nvram_regions(n) > 0 // at least one slot free on n
    POST: env_regions(env') INCLUDES env_regions(env)
          AND
          #(env_regions(env')) > #(env_regions(env))
          AND
          EXISTS n' IN env_nodes(env').
            (EXISTS n IN env_nodes(env).
              node_id(n') == node_id(n) == node_id
              AND
              node_free_nvram_regions(n') < node_free_nvram_regions(n))
          AND
          env_region_id(env') > env_region_id(env)
          // Note: missing nvram check on region alloc'd on n
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

// Delete n's region with the given id, elimintating it from the environment, as
// well.
region_nvram_delete def= Env -> Int -> Int -> Env
region_nvram_delete env node_id region_id env' =
  INV_BEGIN
  PRE:  EXISTS n IN env_nodes(env). 
          node_id(n) == node_id
          AND
          (EXISTS r IN node_nvram_rgns(n).
            region_id(r) == region_id)
        AND
        EXISTS r IN env_regions(env). region_id(r) == region_id
  POST: EXISTS n' IN env_nodes(env'). 
          (EXISTS n IN env_nodes(env). 
            node_id(n') == node_id(n) == node_id
            AND
            (NOT EXISTS r IN node_rgns(n').
              region_id(r) == region_id)
            AND
            node_nvram_region_capacity(n') > node_nvram_region_capacity(n)
            AND
            #(node_nvram_rgns(n')) < #(node_nvram_rgns(n)))
        AND
        NOT EXISTS r IN env_regions(env). region_id(r) == region_id
        AND
        #(env_regions(env')) < #(env_regions(env))
  INV_END
  BODY_BEGIN
    RETURN env'
  BODY_END
END

///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

// Used for generating unique IDs, which at this time are just strictly
// increasing integers.
succ def= Int -> Int
succ i i' =
  INV_BEGIN
  POST: i' > i
  INV_END
  BODY_BEGIN
    RETURN i + 1
  BODY_END
END
